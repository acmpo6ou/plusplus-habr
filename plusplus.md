# plusplus – операторы унарного инкремента и декремента в python

[plusplus](https://github.com/borzunov/plusplus) – это маленькая библиотека которая добавляет операторы унарного инкремента и декремента в python.
Ниже привожу перевод README plusplus в котором объясняется, как библиотека работает.
Приятного чтения!

## Предисловие

По умолчанию python не поддерживает ни пре-инкременты (`++x`), ни пост-инкременты (`x++`).
Тем не менее в python конструкция `++x` _синтаксически корректна_, так как он парсит ее как две последующие операции `+x`, где `+` это [унарный плюс](https://docs.python.org/3/reference/datamodel.html#object.__pos__) (то же самое с `--x` и [унарным минусом](https://docs.python.org/3/reference/datamodel.html#object.__neg__)).
Обе эти операции не имеют никакого эффекта, так как `-(-x) == +(+x) == x`.

plusplus патчит python байт-код превращая выражения `++x` в `x += 1`.
Также поддерживаются инкременты и декременты элементов коллекций и атрибутов объектов, например:

```python
some_dict = {'key': 42}
++some_dict['key']
assert some_dict['key'] == 43
```

В отличие от `x += 1`, `++x` это выражение, так что оно прекрасно работает внутри других выражений, в условиях if/while, в лямбдах и в генераторах списков и словарей (list/dict comprehensions):

```python
array[++index] = new_value

if --connection.num_users == 0:
    connection.close()

# Выражение `global counter` не нужно благодаря инкременту
button.add_click_callback(lambda: ++counter)

index = 0
indexed_cells = {++index: cell for row in table for cell in row}
```

[Здесь](https://github.com/borzunov/plusplus/blob/main/tests/test_plusplus.py) можете посмотреть более сложные примеры.

## Зачем вообще создавать подобные библиотеки, не зря же инкременты запрещены в python?

Я бы не сказал что использовать инкременты в реальных проектах хорошая идея: с ними код может стать менее читабельным, сбить с толку новых разработчиков и вообще работать по другому если его скопировать куда-нибудь, где модуль plusplus не установлен.
Я создал этот модуль по приколу, как демонстрация гибкости python и техник манипуляции байт-кодом.

Тем не менее существуют ситуации, когда инкременты могут упростить код ([здесь](https://github.com/borzunov/plusplus/blob/main/docs/stdlib_examples.md) можете посмотреть примеры из стандартной библиотеки python).
Также инкременты похожи на выражения присваивания (те которые используют оператор `:=` появившийся в [PEP572](https://www.python.org/dev/peps/pep-0572/)).

## Как все устроено

### Патчинг байт-кода

Python компилирует весь исходный код в низкоуровневый [байт-код](https://docs.python.org/3.7/library/dis.html) который исполняется в виртуальной машине питона. Каждая инструкция байт-кода берет несколько элементов из стека, делает что-нибудь с ними и возвращает результат назад в стек.

Выражение `++x` компилируется в две последующие инструкции [UNARY_POSITIVE](https://docs.python.org/3.7/library/dis.html#opcode-UNARY_POSITIVE) которые не сохраняют никакого промежуточного результата (то же самое и с `--x` и двумя инструкциями [UNARY_NEGATIVE](https://docs.python.org/3.7/library/dis.html#opcode-UNARY_NEGATIVE)).

`++x` единственное выражение которое может произвести подобный байт-код паттерн (две последующие операции `UNARY_POSITIVE`). Это значит что мы можем заменить этот паттерн на байт-код для выражения `x += 1`.
Именно это и делает plusplus, он заменяет две идущие подряд операции `UNARY_POSITIVE` на байт-код для `x += 1`.
Вот что происходит с выражением `y = ++x`:

![Байт-код для y = ++x](/home/kotlin/Downloads/plusplus/bytecode_1.png)

Похожая, но более сложная трансформация происходит для выражения `value = ++dictionary['key']`.
Инструкции в желтых блоках сохраняют исходное местоположение и возвращаются к нему когда операция инкремента закончена (смотрите объяснение ниже):

![Байт-код для value = ++dictionary['key']](/home/kotlin/Downloads/plusplus/bytecode_2.png)

Этот байт-код похож на то во что компилируется выражение `dictionary['key'] += 1`. Единственное отличие: пропатченный байт-код хранит дополнительную копию инкрементированого значения для того чтобы мы могли вернуть это значение и присвоить его переменной `value`.

Самая непонятная часть находится во втором желтом блоке. Он нужен только для того, чтобы изменить порядок верхних четырех элементов стека. Если бы нам надо было упорядочить верхние 2 или 3 элемента мы могли бы просто использовать инструкции [ROT_TWO](https://docs.python.org/3.7/library/dis.html#opcode-ROT_TWO) и [ROT_THREE](https://docs.python.org/3.7/library/dis.html#opcode-ROT_THREE) (они по кругу сдвигают указанное количество элементов стека). Если бы у нас была инструкция `ROT_FOUR` мы могли бы заменить второй желтый блок двумя `ROT_FOUR`, для того чтобы отсортировать элементы как нам надо.

Проблема в том что инструкцию `ROT_FOUR` убрали в Python 3.2 (потому что компилятор ее [редко использовал](https://bugs.python.org/issue929502)) и ее вернули только в Python 3.8. Так что если мы хотим поддерживать Python 3.3 - 3.7, нам придется идти обходным путем и использовать инструкции [BUILD_TUPLE](https://docs.python.org/3.7/library/dis.html#opcode-BUILD_TUPLE) и [UNPACK_SEQUENCE](https://docs.python.org/3.7/library/dis.html#opcode-UNPACK_SEQUENCE). `BUILD_TUPLE` заменяет верхние N элементов стека на кортеж сделанный из этих элементов. `UNPACK_SEQUENCE` распаковывает кортеж располагая элементы на стеке справа на лево, т.е. в обратном порядке. Мы используем эти инструкции для того, чтобы перевернуть верхние 4 элемента и потом поменять местами 2 верхних элемента получая таким образом нужный порядок.

### Декоратор @enable_increments

Первый способ использования инкрементов – декорировать функцию в которой они нам нужны.

Декоратор @enable_increments дизассемблит байт-код функции, патчит в нем выше описанные паттерны и рекурсивно вызывает себя для всех вложенных объектов байт-кода (таким образом, функции и классы вложенные в нашу функцию будут тоже пропатчены).

Дизассемблим и собираем байт-код назад мы с помощью [вот этой](https://github.com/MatthieuDartiailh/bytecode) библиотеки.

### Инкременты для целого пакета

Система импорта в Python позволяет загружать модули не только из файлов, но и с других обоснованных мест (например есть [модуль](https://github.com/drathier/stack-overflow-import) который позволяет импортировать код из ответов на StackOverflow). Все что надо сделать это предоставить контент модуля, включая его байт-код.

Таким образом мы можем написать загрузчик, который импортирует модуль и патчит его байт-код. Для этого надо создать новый [MetaPathFinder](https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder) и установить его в [sys.meta_path](https://docs.python.org/3/library/sys.html#sys.meta_path).

## Разве нельзя просто перегрузить оператор унарного плюса?

Нельзя, потому что:

* Невозможно будет отличить применение двух последующих унарных операторов (как в `++x`) от простого их применения (как показано ниже). Ведь очень важно различать `+x` и `++x`.
    ```
    x = -value
    y = -x
    ```

* Перегрузка операторов с помощью магических методов (таких как [`__pos__()`](https://docs.python.org/3/reference/datamodel.html#object.__pos__) и [`__neg__()`](https://docs.python.org/3/reference/datamodel.html#object.__neg__)) не работает с встроенными типами, например `int` и `float`. Можно правда использовать разные хаки как например в [forbiddenfruit](https://github.com/clarete/forbiddenfruit) и [dontasq](https://github.com/borzunov/dontasq#adding-methods-to-built-ins), но использование подобных хаков усложняет портирование plusplus на другие версии питона и интерпретаторов.

* Пришлось бы перегружать операторы каждого встроенного или кастомного числового типа. В то время как метод с патчингом байт-кода работает для всех типов автоматически.

## Проблемы с pytest

pytest вносит модификации в байт-код тестов, чтобы сохранить промежуточные результаты выражений в инструкции `assert`. Это нужно, для того чтобы показать результаты, если тест упадет (смотрите [документацию pytest](https://docs.pytest.org/en/stable/assert.html#assertion-introspection-details)).

Из-за этой особенности, pytest ломает наш патчер ведь две инструкции `UNARY_POSITIVE` разделяются кодом который сохраняет результат первой инструкции `UNARY_POSITIVE`.
Мы решаем проблему удаляя код сохранения некоторых промежуточных результатов.

## Как использовать plusplus?

Установите его с помощью pip:

```
pip install plusplus
```

### Для функций и методов используйте декоратор

```python
from plusplus import enable_increments

@enable_increments
def increment_and_return(x):
    return ++x
```

Теперь инкременты будут доступны всему коду функции, включая вложенные в нее функции и классы.

### Для всего кода вашего пакета

В `package/__init__.py`, сделайте вот такой вызов перед импортированием модулей:

```python
from plusplus import enable_increments

enable_increments(__name__)

# Здесь можно импортировать модули
...
```

Таким образом инкременты будут доступны во всех модулях вашего пакета, но не в `package/__init__.py`.

## Еще идеи

Метод с патчингом байт-кода можно было бы применить для того что бы сделать [выражения присваивания](https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions) (те которые используют оператор `:=`) доступными для версий Python которые их не поддерживают. Например, мы могли бы заменять выражения `x <-- value` (два унарных минуса и одно сравнение) на присвоение `x` значения `value`.

## Вам также может быть интересно

[cpmoptimize](https://habr.com/ru/post/236689/) – автоматическая оптимизация алгоритмов с помощью быстрого возведения матриц в степень. Статья написана автором plusplus.

## Благодарности

* Спасибо Александру за то что создал такую прикольную библиотеку, разрешил мне ее перевести и помог опубликовать
* Спасибо вам за то что читали!
