plusplus – операторы унарного инкремента/декремента в python

plusplus – это маленькая библиотека которая добавляет операторы унарного инкремента и декремента в python. Ниже привожу перевод README plusplus в котором объясняется как библиотека работает. Приятного чтения!

Предисловие

По умолчанию python не поддерживает ни пре-инкременты (++x) ни пост-инкременты (x++). Тем не мение, в python конструкция ++x синтаксически корректна так как он парсит ее как две последующие операции +x где + это унарный плюс (тоже самое с --x и унарным минусом). Обе эти операции не имеют никакого эффекта так как -(-x) == +(+x) == x.

plusplus патчит python байткод превращая выражения ++x в x += 1. Также поддерживаются инкременты и декременты элементов коллекций и атрибутов объектов, например:

some_dict = {'key': 42}
++some_dict['key']
assert some_dict['key'] == 43

В отличии от x += 1, ++x это выражение, так что оно прекрасно работает внутри других выражений, в условиях if/while, в лямбдах и в генераторах списков и словарей (list/dict comprehensions):

array[++index] = new_value

if --connection.num_users == 0:
    connection.close()

# Выражение `global counter` не нужно благодаря инкременту
button.add_click_callback(lambda: ++counter)

index = 0
indexed_cells = {++index: cell for row in table for cell in row}

Здесь можете посмотреть более сложные примеры.

Зачем вообще создавать подобные библиотеки, не зря же инкременты запрещены в python?

Я бы не сказал что использовать инкременты в реальных проэктах хорошая идея: с ними код может стать менее читабельным, сбить с толку новых разработчиков и вообще работать по другому если его скопировать куда-нибуть где модуль plusplus не установлен. Я создал этот модуль по приколу как демонстрация гибкости python и техник манипуляции байткодом.
Тем не мение существуют ситуации когда инкременты могут упростить код (здесь можете посмотреть примеры из стандартной библиотеки python). Также инкременты похожи на выражения присваивания (те которые используют оператор := появившийся в PEP572)

Как все устроено

Патчинг байткода

Python компилирует весь исходный код в низкоуровневый байткод который исполняется в виртуальной машине питона. Каждая инструкция байткода берет несколько елементов из стэка, делает что-нибуть с ними и возвращает результат назад в стэк.
Выражение ++x компилируется в две последующие инструкции UNARY_POSITIVE которые не сохраняют никакого промежуточного результата (тоже самое и с --x и двумя инструкциями UNARY_NEGATIVE).
Выражение ++x единственное выражение которое может произвести подобный байткод патерн (две последующие операции UNARY_POSITIVE). Это значит что мы можем заменить этот патерн на байткод для выражения x += 1.
Именно это и делает plusplus, он заменяет две идущие подряд операции UNARY_POSITIVE на байткод для x += 1.
Вот что происходит с выражением y = ++x:

image

Похожая но более сложная трансформация происходит для выражения value = ++dictionary['key'].
Инструкции в желтых блоках сохраняют исходное местоположение и возвращаются к нему когда операция инкремента закончена (смотрите объяснение ниже):

image

Этот байткод похож на то во что компилируется выражение dictionary['key'] += 1. Единственное отличие: пропатченый байткод хранит дополнительную копию инкрементированого значения для того чтобы мы могли вернуть это значение и присвоить его перменной value.
