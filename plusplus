plusplus – операторы унарного инкремента/декремента в python

plusplus – это маленькая библиотека которая добавляет операторы унарного инкремента и декремента в python. Ниже привожу перевод README plusplus в котором объясняется как библиотека работает. Приятного чтения!

Предисловие

По умолчанию python не поддерживает ни пре-инкременты (++x) ни пост-инкременты (x++). Тем не мение, в python конструкция ++x синтаксически корректна так как он парсит ее как две последующие операции +x где + это унарный плюс (тоже самое с --x и унарным минусом). Обе эти операции не имеют никакого эффекта так как -(-x) == +(+x) == x.

plusplus патчит python байткод превращая выражения ++x в x += 1. Также поддерживаются инкременты и декременты элементов коллекций и атрибутов объектов, например:

some_dict = {'key': 42}
++some_dict['key']
assert some_dict['key'] == 43

В отличии от x += 1, ++x это выражение, так что оно прекрасно работает внутри других выражений, в условиях if/while, в лямбдах и в генераторах списков и словарей (list/dict comprehensions):

array[++index] = new_value

if --connection.num_users == 0:
    connection.close()

# Выражение `global counter` не нужно благодаря инкременту
button.add_click_callback(lambda: ++counter)

index = 0
indexed_cells = {++index: cell for row in table for cell in row}

Здесь можете посмотреть более сложные примеры.

Зачем вообще создавать подобные библиотеки, не зря же инкременты запрещены в python?

Я бы не сказал что использовать инкременты в реальных проэктах хорошая идея: с ними код может стать менее читабельным, сбить с толку новых разработчиков и вообще работать по другому если его скопировать куда-нибуть где модуль plusplus не установлен. Я создал этот модуль по приколу как демонстрация гибкости python и техник манипуляции байткодом.
Тем не мение существуют ситуации когда инкременты могут упростить код (здесь можете посмотреть примеры из стандартной библиотеки python). Также инкременты похожи на выражения присваивания (те которые используют оператор := появившийся в PEP572)

Как все устроено

Патчинг байткода

Python компилирует весь исходный код в низкоуровневый байткод который исполняется в виртуальной машине питона. Каждая инструкция байткода берет несколько елементов из стэка, делает что-нибуть с ними и возвращает результат назад в стэк.
Выражение ++x компилируется в две последующие инструкции UNARY_POSITIVE которые не сохраняют никакого промежуточного результата (тоже самое и с --x и двумя инструкциями UNARY_NEGATIVE).
Выражение ++x единственное выражение которое может произвести подобный байткод патерн (две последующие операции UNARY_POSITIVE). Это значит что мы можем заменить этот патерн на байткод для выражения x += 1.
Именно это и делает plusplus, он заменяет две идущие подряд операции UNARY_POSITIVE на байткод для x += 1.
Вот что происходит с выражением y = ++x:

image

Похожая но более сложная трансформация происходит для выражения value = ++dictionary['key'].
Инструкции в желтых блоках сохраняют исходное местоположение и возвращаются к нему когда операция инкремента закончена (смотрите объяснение ниже):

image

Этот байткод похож на то во что компилируется выражение dictionary['key'] += 1. Единственное отличие: пропатченый байткод хранит дополнительную копию инкрементированого значения для того чтобы мы могли вернуть это значение и присвоить его перменной value.
Самая непонятная часть находится во втором желтом блоке. Он нужнен только для того чтобы изменить порядок верхних четырех элементов стэка. Если бы нам надо было упорядочить верхние 2 или 3 элемента мы могли бы просто  использовать инструкции ROT_TWO и ROT_THREE (они покругу сдвигают указаное количество элементов стэка). Если бы у нас была инструкция ROT_FOUR мы могли бы заменить второй желтый блок двумя ROT_FOUR для нужной сортировки элементов.
Проблемма в том что инструкцию ROT_FOUR убрали в Python 3.2 (потому что компилятор  ее редко использовал) и ее вернули только в Python 3.8. Так что если мы хотим поддерживать Python 3.3 - 3.7, нам придется идти обходным путем и использовать инструкции BUILD_TUPLE и UNPACK_SEQUENCE. BUILD_TUPLE заменяет верхние N элементов стэка на кортеж сделаный из этих элементов. UNPACK_SEQUENCE распаковует кортеж располагая элементы на стэке справа на лево, т.е. в обратном порядке. Мы используем эти инструкции для того чтобы перевернуть верхние 4 элемента и потом поменять местами 2 верхних элемента получая таким образом нужный порядок.

Декоратор @enable_increments

Первый способ использования инкрементов – декорировать функцию в которой они нам нужны.
Декоратор @enable_increments дизасемблит байткод функции, патчит в нем выше описаные патерны и рекурсивно вызивает себя для всех вложеных объектов байткода (таким образом функции и классы вложеные в нашу функцию будут тоже пропатчены).
Дизасемблим и собираем байткод назад мы с помощью вот этой библиотеки.

Инкременты для целого пакета

Система импорта в Python позволяет загружать модули не только из файлов но и с других обоснованых мест (например есть модуль который позволяет импортировать код из ответов на StackOverflow). Все что надо сделать это предоставить контент модуля, включая его байткод.
Таким образом мы можем написать загрузчик который импортирует модуль и патчит его байткод. Для этого надо создать новый MetaPathFinder и установить его в sys.meta_path.

Разве нельзя просто пегрузить оператор унарного плюса?

Нельзя, потому что:

Невозможно будет отличить применение двух последующих унарных операторов (как в ++x) от простого их применения (как показано ниже). Ведь очень важно различать +x и ++x.

x = -value
y = -x

Перегрузка операторов с помощью магических методов (таких как __pos__() и __neg__()) не работает с встроеными типами, например int и float. Можно правда использовать разные хаки как например в forbiddenfruit и dontasq, но использование подобных хаков усложняет портирование plusplus на другие версии питона и интерпретаторов.

Пришлось бы перегружать операторы каждого встроеного или кастомного числового типа. В то время как метод с патчингом байткода работает для всех типов автоматически.
